---
layout: post
title: WebPack4 配置
tags: [WebPack]
---

# 前言

webpack 几个核心的概念

- entry: 入口模块，开始构建的地方
- output: 输出的文件和目录定义
- loaders: 把 webpack 无法处理的非 js 文件处理成它可以处理的模块
- plugins: 插件，更多做的事情是优化，比如提取公共模块，压缩处理 js/css/html，和进行功能的扩展
- chunk: Code Splitting 产物，抛弃了 webpack3 的 CommonsChunkPlugin。特点是配置简单，当 mode 是 production 的时候就会自动开启 Code Splitting，完成某些公共模块的去重，打包成一个单独的 chunk

# 基础知识

### 什么是 webpack

模块打包工具，把多个模块最终打包成一个 bundle.js 的问题

### 安装 webpack

需要 node 和 npm

初始化项目 npm init -y 生成一个 package.json 文件

```json
{
  "name": "webpack4", // 包名
  "version": "1.0.0", // 版本号
  "description": "", // 描述
  "main": "index.js", // 别人引用模块的时候入口文件，默认根目录下的 index.js
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [], // 关键字
  "author": "", // 作者，可以在 npmjs.org 注册的，格式为 账号名<邮件>
  "license": "ISC"
}
```

安装局部的 webpack

```
yarn add webpack webpack-cli -D
```

可以通过 `npx webpack -v` 查看版本号

### 配置文件

`webpack.config.js` 是 webpack 默认的配置文件

比如基本的配置

```js
const path = require('path');

module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'bundle.js',
    path: path.join(__dirname, 'dist'),
  },
};
```

运行一下 `npx webpack`

```bash
Hash: 69bfeeb992cfa927c35a
Version: webpack 4.44.1
Time: 220ms
Built at: 2020-08-23 7:43:36 ├F10: PM┤
    Asset       Size  Chunks             Chunk Names
bundle.js  959 bytes       0  [emitted]  main
Entrypoint main = bundle.js
[0] ./src/index.js 31 bytes {0} [built]

WARNING in configuration
The 'mode' option has not been set, webpack will fallback to 'production' for this value. Set 'mode' option to 'development' or 'production' to enable defaults for each environment.
You can also set it to 'none' to disable any default behavior. Learn more: https://webpack.js.org/configuration/mode/
```

另外默认的名字是 `webpack.config.js`，当然你也可以使用 `--config webpack.prod.config.js` 来指定不同的配置文件

### npm scripts

我们添加一些类似经常用到的 `npm run dev` 的 `npm scripts`，在 `package.json` 加入

```json
"scripts": {
  "dev": "webpack --config webpack.config.js"
}
```

这个时候执行 `yarn dev` 就会执行对应的 `scripts` 了

### webpack-cli 作用

如果不安装这个包，在命令行执行 `webpack` 是没有反应的

### 配置环境

分为 `development` 和 `production` 两个环境，默认是 `production` ，后者会对打包后的文件进行压缩，我们可以加上这个配置。重新运行 `yarn dev` 发现打包后的文件没有压缩了

```js
const path = require('path');

module.exports = {
  mode: 'development',
  entry: './src/index.js',
  output: {
    filename: 'bundle.js',
    path: path.join(__dirname, 'dist'),
  },
};
```

# loaders

loader 是打包的方案，指定对于某种文件用什么方式打包。webpack 本身对一些文件是不知道怎么打包的，所以需要借助 loader，比如图片 字体图标。我们进入到我们的配置文件进行配置

比如 file-loader

### file-loader

```js
const path = require('path');

module.exports = {
  mode: 'development',
  entry: './src/index.js',
  output: {
    filename: 'bundle.js',
    path: path.join(__dirname, 'dist'),
  },
  module: {
    rules: [
      {
        test: /\.(png|jpg|gif|jpeg)$/,
        use: 'file-loader',
      },
    ],
  },
};
```

安装好依赖 `yarn add file-loader -D` 然后引入一个头像试试

```js
import avatar from './images/3488257.jpeg';

console.log('hello webpack4');
console.log(avatar);
```

可以发现成功引入

```bash
yarn run v1.22.4
warning ../../package.json: License should be a valid SPDX license expression
$ webpack --config webpack.config.js
Hash: c9a9428cfd0b132b4f78
Version: webpack 4.44.1
Time: 119ms
Built at: 2020-08-23 7:57:54 ├F10: PM┤
                                Asset      Size  Chunks             Chunk Names
a19766eaf83c4e704f0220abb52d7c7f.jpeg  26.4 KiB          [emitted]
                            bundle.js  4.63 KiB    main  [emitted]  main
Entrypoint main = bundle.js
[./src/images/3488257.jpeg] 81 bytes {main} [built]
[./src/index.js] 97 bytes {main} [built]
```

我们可以给它增加一些配置项

```js
{
  test: /\.(png|jpg|gif|jpeg)$/,
  use: {
    loader: 'file-loader',
    options: {
      name: '[name]_[hash].[ext]',
    },
  },
},
```

打包出来了一个 `3488257_a19766eaf83c4e704f0220abb52d7c7f.jpeg` 这样的文件，name 就是原始名称,hash 使用的是 MD5 算法,ext 就是后缀

我们想把图片都放在 `dist/images` 里面的话，再加一个配置

```js
{
  test: /\.(png|jpg|gif|jpeg)$/,
  use: {
    loader: 'file-loader',
    options: {
      name: '[name]_[hash].[ext]',
      outputPath: 'images',
    },
  },
},
```

可以看到已经打包到我们指定的目录了 `images/3488257_a19766eaf83c4e704f0220abb52d7c7f.jpeg`

如果我们要配置字体文件的话，加入下面这段就好了

```js
{
  test: /\.(woff|woff2|eot|ttf|otf)$/,
  use: ['file-loader'],
},
```

### url-loader

接下来介绍一下 url-loader

其实上面的 file-loader 配置我们完全可以改成用 url-loader，它们的区别是什么呢

这主要看 url-loader 的 limit 配置

- 如果图片的大小比 limit 大，表现和 file-loader 一样
- 否则以 base64 的形式打包进去

我们直接使用 url-loader 就好了，修改如下

```js
{
  test: /\.(png|jpg|gif|jpeg)$/,
  use: {
    loader: 'url-loader',
    options: {
      name: '[name]_[hash].[ext]',
      outputPath: 'images',
      limit: 102400, //100KB
    },
  },
},
```

运行 `yarn dev` 以后发现没有生成图片文件，查看 `bundle.js` 文件发现引入的图片模块是一串 base64 字符串 `"data:image/jpeg;base64,/9j/2wCEAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwg...`

### css-loader

我们引入样式文件需要 css-loader 和 style-loader

```bash
yarn add css-loader style-loader -D
```

加入配置

```js
{
  test: /\.css$/,
  use: ['style-loader', 'css-loader'],
},
```

引入 css 文件

```js
import avatar from './images/3488257.jpeg';
import './styles/index.css';

console.log('hello webpack4');
console.log(avatar);
```

发现正常打包，样式文件进入了 `bundle.js` 中

- css-loader 主要作用是把多个 css 文件整合在一起生成一个 css 文件
- style-loader 主要作用是把整合的 css 文件挂载到 head 标签内

### less-loader

如果我们要引入 `less` 文件呢？增加依赖 `yarn add less-loader less -D`，修改配置

```
{
  test: /\.(css|less)$/,
  use: ['style-loader', 'css-loader', 'less-loader'],
},
```

引入 less 文件

```less
@blue: #1875e7;
div {
  color: @blue;
}
```

```js
import avatar from './images/3488257.jpeg';
import './styles/index.css';
import './styles/index.less';

console.log('hello webpack4');
console.log(avatar);
```

正常导入

### postcss-loader

如果我们想加入一些需要 css3 前缀的样式怎么办，可以使用 `postcss-loader`

`yarn add postcss-loader autoprefixer -D`

我们新增一个 `postcss.config.js` 文件，写入

```js
module.exports = {
  plugins: [
    require('autoprefixer')({
      overrideBrowserslist: [
        'Android 4.1',
        'iOS 7.1',
        'Chrome > 31',
        'ff > 31',
        'ie >= 8',
      ],
    }),
  ],
};
```

然后修改下配置文件

```js
{
  test: /\.(css|less)$/,
  use: ['style-loader', 'css-loader', 'postcss-loader', 'less-loader'],
},
```

修改 less 文件

```less
@blue: #1875e7;

.test {
  color: @blue;
  display: flex;
}
```

发现打包之后的文件是正常把前缀加上了

但是发现如果在 `index.less` 文件引入另外一个 less 文件，它就不会按照我们规定的 loader 来执行了

按照自己的理解，它已经变成了 css 文件之后再进行 @import ，所以不会再走 postcss-loader 和 less-loader 了。修改成下面这样。参考 https://webpack.js.org/loaders/css-loader/#importloaders

```js
{
  test: /\.(css|less)$/,
  use: [
    'style-loader',
    {
      loader: 'css-loader',
      options: {
        importLoaders: 2,
        modules: true,
      },
    },
    'postcss-loader',
    'less-loader',
  ],
},
```

里面有这么一段说明：

```
The option importLoaders allows you to configure how many loaders before css-loader should be applied to @imported resources.
```

```js
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/i,
        use: [
          'style-loader',
          {
            loader: 'css-loader',
            options: {
              importLoaders: 2,
              // 0 => no loaders (default);
              // 1 => postcss-loader;
              // 2 => postcss-loader, sass-loader
            },
          },
          'postcss-loader',
          'sass-loader',
        ],
      },
    ],
  },
};
```

另外如果希望自己的样式文件是局部的不是全局的，加上 `modules: true` 配置就好了。感觉这个就是类似于 vue 里面写 `<style scope>` 的方式，生成的样式文件是局部的

# plugins

插件是可以运行到某个时候帮你做一些事情

### HtmlWebpackPlugin

这个插件的作用是给你生成一个 html 文件，把打包好的 js 文件插入到 body 标签前

`yarn add html-webpack-plugin -D`

我们进行下面的配置

```js
const HtmlWebpackPlugin = require('html-webpack-plugin');

...
plugins: [
  new HtmlWebpackPlugin({
    template: 'src/index.html',
  }),
],
...
```

打包以后可以发现构建的产物多了一个 html 文件

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script src="bundle.js"></script>
  </body>
</html>
```

### CleanWebpackPlugin

我们构建的产物如果每次使用不同的 hash，老的文件会堆积起来，可以每次构建前把构建目录里面的内容删除掉

`yarn add clean-webpack-plugin -D`

引入 `const { CleanWebpackPlugin } = require('clean-webpack-plugin');`

加入配置

```js
plugins: [
  new HtmlWebpackPlugin({
    template: 'src/index.html',
  }),
  new CleanWebpackPlugin(),
],
```

最新的 webpack4 不需要自己去配置路径，默认就是 dist

# 核心概念

### entry && output

我们可以配置多个入口文件和出口文件，比如

```js

entry: {
  index: './src/index.js',
  home: './src/home.js'
}

output: {
  name: '[name].js',
  publicPath: "https://cdn.example.com/assets/",
}
```

publicPath 主要是把资源修改到 cdn 地址，如果我们的资源正常发布到 cdn 上

### sourcemap

devtool 配置 source-map 的作用是代码出现问题可以映射到源文件下的错误

一般的配置如下：

- development 环境使用 devtool: 'cheap-module-eval-source-map'
- production 环境使用 devtool:'cheap-module-source-map'

在测试环境加上了 `devtool: 'cheap-module-eval-source-map',` 以后，点击控制台中的文件，可以看到源文件的代码位置了

### webpack-dev-server

主要是方便本地开发 `yarn add webpack-dev-server -D`，开启一个服务器，实时监听打包文件是否变化

我们新增配置

```js
devServer: {
  contentBase: path.join(__dirname, 'dist'),
  compress: true, // 启用 gzip 压缩
  port: 9000,
  open: true,
},
```

调整一下 npm scripts

```json
"scripts": {
  "dev": "webpack-dev-server",
  "build": "webpack --config webpack.config.js"
},
```

执行 `yarn dev`，发现我们只要修改了文件，浏览器也会实时刷新了

另外也没有生成 dist 文件夹下的文件，它是打包到内存的

### 模块热更新 hot module replacement

本地环境运行的时候 替换，添加或者删除模块，而不需要重新加载整个页面

我们只需要加多一个配置以及添加两个新的 plugins

```js
const webpack = require('webpack');

devServer: {
  contentBase: path.join(__dirname, 'dist'),
  compress: true, // 启用 gzip 压缩
  port: 9000,
  open: true,
  hot: true, // 启动模块热更新
},

...
plugins: [
  new HtmlWebpackPlugin({
    template: 'src/index.html',
  }),
  new CleanWebpackPlugin(),
  new webpack.NamedModulesPlugin(),
  new webpack.HotModuleReplacementPlugin(),
],
...
```

NamedModulesPlugin 的作用是更加容易查看要修补 patch 的依赖。

对于 css 模块，css-loader 会帮我们做好实时热更新，对于 js 我们需要手动配置

```js
if (module.hot) {
  module.hot.accept('./print', () => {
    print();
  });
}
```

上面表示的就是接受一个需要模块热更新的模块，变化的时候会帮我们检测到然后执行回调函数

### babel 处理 es6 语法

- babel-loader
- @babel/core 核心库
- @babel/preset-env 把语法翻译成 es5 语法，包含所有翻译成 es5 的语法规则
- @babel/polyfill 把 Promise,map 等低版本中没有实现的语法,用 polyfill 来实现.

`yarn add babel-loader @babel/core @babel/preset-env -D`

`yarn add @babel/polyfill`

加上下面的配置

```js
{
  test: /\.js$/,
  loader: 'babel-loader',
  exclude: /node_modules/,
  options: {
    presets: [
      [
        '@babel/preset-env',
        {
          useBuiltIns: 'usage',
        },
      ],
    ],
  },
},
```

发现我们构建以后的 `const` 都替换成 `var` 了

不过一些低版本浏览器还是不支持 promise map

所以我们在头部引入

```js
import '@babel/polyfill';
```

但在这样以后打包的文件大了很多（从 160kb 涨到了 1.04mb），因为它要引入很多 polyfill 去实现 promise 等功能。我们在配置里面加了以下配置，那就只会引入我们使用到了语法了

```js
useBuiltIns: 'usage',
```

但是当我们生成第三方模块时,或者是生成 UI 组件库时，会产生新的问题，babel 会污染环境，我们引入 @babel/plugin-transform-runtime

`yarn add @babel/plugin-transform-runtime -D`

`yarn add @babel/runtime`

创建一个 .babelrc 文件，写入下面的配置

```json
{
  "plugins": [
    [
      "@babel/plugin-transform-runtime",
      {
        "corejs": 2,
        "helpers": true,
        "regenerator": true,
        "useESModules": false
      }
    ]
  ]
}
```

`yarn add @babel/runtime-corejs2`

我们就可以不在入口文件引入 @babel/polyfill 了

# 高级概念

### 使用 tree shaking

可以看下这个 https://juejin.im/post/6844903544756109319

把程序想成一棵树，绿色是用到的，灰色是没用到的，表示死去的枯叶，所以需要抖动来让它们落下

所以我们引入模块的时候一些没用到的代码不想打包进去，通过 tree shaking 可以删除无用代码

webpack4 production 默认情况下是启用了的

optimization.usedExports 使 webpack 确认每个模块导出项的使用情况，依赖于 optimization.providedExports 的配置

optimization.usedExports 收集到的信息会被其他优化项和产出代码使用到（模块未用到的导出项不会被导出，在语法完全兼容的情况下会把导出名称混淆为单个 char）

为了最小化代码体积，未用到的导出项会被删除

为了使用 tree shaking，需要使用 ES Module 语法，也就是使用 ES2015 模块语法（即 import 和 export

### 将文件标记为无副作用 side-effect-free

有时候我们模块不是太纯粹，无法辨别哪些是需要删除的，我们需要向 webpack 的 compiler 提供提示哪些代码是“纯粹部分”

通过 package.json 的 "sideEffects" 属性来实现的

```json
"sideEffects": false
```

如果所有代码都不包含副作用，我们就可以简单地将该属性标记为 false，来告知 webpack，它可以安全地删除未用到的 export 导出

注意，任何导入的文件都会受到 tree shaking 的影响。这意味着，如果在项目中使用类似 css-loader 并导入 CSS 文件，则需要将其添加到 side effect 列表中，以免在生产模式中无意中将它删除：

于是修改成

```json
"sideEffects": [
  "*.css"
],
```

### development production 环境

- 开发环境需要有实时重新加载(live reloading)或热模块替换(hot module replacement)能力的 source map 和 localhost server
- 正式环境转向于关注更小的 bundle，更轻量的 source map，以及更优化的资源，以改善加载时间。

所以一般会有一个公用的 `webpack.common.js` 配置，另外生产和开发环境各自在配置

这个时候配置的合并就需要用到 webpack-merge

`yarn add webpack-merge -D`

在 build 文件夹下面新建了

webpack.common.js webpack.prod.js webpack.dev.js 三个配置文件，分别内容如下：

```js
// webpack.common.js
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const { CleanWebpackPlugin } = require('clean-webpack-plugin');

module.exports = {
  mode: 'development',
  entry: './src/index.js',
  output: {
    filename: 'bundle.js',
    path: path.join(__dirname, '../dist'),
  },
  module: {
    rules: [
      {
        test: /\.(woff|woff2|eot|ttf|otf)$/,
        use: ['file-loader'],
      },
      {
        test: /\.(png|jpg|gif|jpeg)$/,
        use: {
          loader: 'url-loader',
          options: {
            name: '[name]_[hash].[ext]',
            outputPath: 'images',
            limit: 102400, //100KB
          },
        },
      },
      {
        test: /\.(css|less)$/,
        use: [
          'style-loader',
          {
            loader: 'css-loader',
            options: {
              importLoaders: 2,
              modules: true,
            },
          },
          'postcss-loader',
          'less-loader',
        ],
      },
      {
        test: /\.js$/,
        loader: 'babel-loader',
        exclude: /node_modules/,
        options: {
          presets: [
            [
              '@babel/preset-env',
              {
                useBuiltIns: 'usage',
              },
            ],
          ],
        },
      },
    ],
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: 'src/index.html',
    }),
    new CleanWebpackPlugin(),
  ],
};
```

```js
// webpack.dev.js
const path = require('path');
const webpack = require('webpack');
const { merge } = require('webpack-merge');
const commonConfig = require('./webpack.common');

const devConfig = {
  mode: 'development',
  devtool: 'cheap-module-eval-source-map',
  devServer: {
    contentBase: path.join(__dirname, 'dist'),
    compress: true, // 启用 gzip 压缩
    port: 9000,
    open: true,
    hot: true, // 启动模块热更新
  },
  optimization: {
    usedExports: true,
  },
  plugins: [
    new webpack.NamedModulesPlugin(),
    new webpack.HotModuleReplacementPlugin(),
  ],
};

module.exports = merge(commonConfig, devConfig);
```

```js
// webpack.prod.js
const { merge } = require('webpack-merge');
const commonConfig = require('./webpack.common');

const prodConfig = {
  mode: 'production',
  devtool: 'cheap-module-source-map',
};

module.exports = merge(commonConfig, prodConfig);
```

再调整一下我们的 npm scripts

```json
"scripts": {
  "dev": "webpack-dev-server --config build/webpack.dev.js",
  "build": "webpack --config build/webpack.prod.js"
},
```

最新的 CleanWebpackPlugin 会自己清理输出的文件夹 dist 所以不需要做任何配置改动

```js
new CleanWebpackPlugin(),
```

### SplitChunksPlugin 代码分割

当你有多个入口文件，或者是打包文件需要做一个划分，举个例子，比如第三方库 lodash，jquery 等库需要打包到一个目录下，自己的业务逻辑代码需要打包到一个文件下，这个时候，就需要提取公共模块了，也就需要 SplitChunksPlugin 这个插件登场了。

需要手动配置 optimization.splitChunks

我们看下下面的配置

```js
module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'async',
      minSize: 30000,
      minChunks: 1,
      maxAsyncRequests: 5,
      maxInitialRequests: 3,
      automaticNameDelimiter: '~',
      name: true,
      cacheGroups: {
        vendors: {
          test: /[\\/]node_modules[\\/]/, //匹配node_modules中的模块
          priority: -10, //优先级,当模块同时命中多个缓存组的规则时，分配到优先级高的缓存组
        },
        default: {
          minChunks: 2, //覆盖外层的全局属性
          priority: -20,
          reuseExistingChunk: true, //是否复用已经从原代码块中分割出来的模块
        },
      },
    },
  },
};
```

- chunks: 以什么类型的代码进行分割
  - initial 入口代码块
  - all 全部
  - async 按需加载的代码块
- minSize: 30000 超过 30k 的模块才会提取
- minChunks: 1 至少被多少个模块引用，才会提取新的 chunk
- maxAsyncRequests: 5,分割后，按需加载的代码块最多允许的并行请求数
- maxInitialRequests: 3,分割后，入口代码块最多允许的并行请求数
- automaticNameDelimiter: "~" 代码块命名分割符
- name: true, 每个缓存组打包得到的代码块的名称
- cacheGroups 缓存组，定制相应的规则。

自己根据实际情况去设置相应的规则，每个缓存组根据规则将匹配的模块会分配到代码块（chunk）中，每个缓存组的打包结果可以是单一 chunk，也可以是多个 chunk

可以看下这篇优化 https://juejin.im/post/6844904183917871117

### Lazy-loding 懒加载和 Chunk

在 webpack 中，什么是懒加载，举个例子，当我需要按需引入某个模块时，这个时候，我们就可以使用懒加载，其实实现的方案就是 import 语法，在达到某个条件时，我们才会去请求资源

我们的先借助一个插件，完成对 import 语法的识别

`yarn add @babel/plugin-syntax-dynamic-import -D`

.babelrc 新增配置

```js
{
  "plugins": [
    [
      "@babel/plugin-transform-runtime",
      {
        "corejs": 2,
        "helpers": true,
        "regenerator": true,
        "useESModules": false
      }
    ],
    [
      "@babel/plugin-syntax-dynamic-import"
    ]
  ]
}
```

这样我们就可以自由使用懒加载了

```js
// create.js
async function create() {
  const { default: _ } = await import(/*webpackChunkName:"lodash"*/ 'lodash');
  let element = document.createElement('div');
  element.innerHTML = _.join(['TianTian', 'lee'], '-');
  return element;
}

function demo() {
  document.addEventListener('click', function () {
    create().then((element) => {
      document.body.appendChild(element);
    });
  });
}

export default demo;
```

点击页面后，会触发 create 函数，然后加载 loadsh 库，最后再页面中懒加载 lodash，打包是正常打包，但是呢，有些资源，可以当你触发某些条件，再去加载，这也算是优化手段吧。

Chunk 在 Webpack 里指一个代码块，那具体是指什么样的代码块呢

Chunk 是 Webpack 打包过程中，一堆 module 的集合。Webpack 通过引用关系逐个打包模块，这些 module 就形成了一个 Chunk。

产生 Chunk 的三种途径

- entry 入口
- 异步加载模块
- 代码分割（code spliting）

### css 代码压缩提取

我们需要去将我们的 CSS 文件单独的打包到一个 Chunk 下，所以需要借助一定的插件 mini-css-extract-plugin

`yarn add mini-css-extract-plugin -D`

将 css 提取为独立的文件插件，支持按需加载的 css 和 sourceMap

目前缺失功能，HMR。所以，我们可以把它运用到生成环境中去

需要注意的一点是，当你的 webpack 版本是 4 版本的时候，需要去 package.json 中配置 sideEffects 属性，这样子就避免了把 css 文件作为 Tree-shaking

再进行压缩

`yarn add optimize-css-assets-webpack-plugin -D`